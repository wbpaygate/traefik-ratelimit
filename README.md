# ratelimiter - traefik_ratelimiter

Плагин для сервиса traefik "ratelimiter".

## 1.1. Хранение конфигурации

конфигурация ratelimiter хранится как в файле cfg/ratelimit.json вместе с самим плагином и в keeper для оперативного управления ratelimiter.
данная конфигурация предназначены для конфигурирования лимитов скорости обработки запросов в зависимости от пути и/или содержимого заголовка запроса.
конфигурация, включает следующие параметры:

- **Лимиты (`limits`)**
    - *Тип:* Массив структур
    - *Обязательность:* Да

  - **Правила (`rules`)**
      - *Тип:* Массив структур
      - *Обязательность:* Да
      - *Примечание:* Содержит правила выбора запросов для лимитирования скорости. для применеия лимита дочтаточно соответствия хотя бы одному правилу
 
      - **Патерн пути (`urlpathpattern`)**
        - *Тип:* Строка
        - *Обязательность:* Да
        - *Чуствительность к регистру:* Да
        - *Примечание:* Если значение не пустое, то правило будет применено если путь http запроса соответствует паттеру. Описание:
          - патерн содержит элементы пути http запроса разделенные символом **/**

      - **Ключ из заголовка http запроса (`headerkey`)**
        - *Тип:* Строка
        - *Обязательность:* Да
        - *Чуствительность к регистру:* Нет
        - *Примечание:* Значение ключа из http запроса. Если значение не пустое, то правило будет применено в том случае если запрос содержит значение headerval в значении заголовка соответстущего ключа

      - **Значение соответствующего ключа из заголовка (`headerval`)**
        - *Тип:* Строка
        - *Обязательность:* Да
        - *Чуствительность к регистру:* Нет
        - *Примечание:* Значение соответствующего ключа в запросе. Данное значение используется только в том случае если указано не пустое значение headerkey

  - **Лимит (`limit`)**
      - *Тип:* Целое число
      - *Обязательность:* Да
      - *Примечание:*  Лимит скорости в запросах в секунду. На запросы сверх лимита будет отправлен ответ со статусом: 429 Too Many Requests.



Конфигурация хранится как в локальном кеше ratelimiter

## 1.2. Обновление конфигурации

Конфигурация обновляется периодически 1 раз в 30 сек из keeper



## Логика работы ratelimiter

### 1. По `wbpayID` (если указан)




- Если запрос содержит айди датацентра в хедере:
    - Если датацентр с таким айди существует и не задизейблен (`disabled = false`) и здоров (`health = true`):
        - Запрос будет спроксирован на этот датацентр.
    - В противном случае вернется ошибка.






где:
  - rules:
    
    в любом правиле должны быть указан "endpointpat" и/или  "headerkey" и "headerval"
    где:
      - endpointpat:
        - патерн для сравнения пути из запроса может содержать символы * это означает эта часть пути запроса может содержать любое значение
        - после нахождения символов ** остальная часть пути будет сравниваться с хвостом пути
          например патерну: ```/api/v2/**/methods``` будут соответствовать пути запроса которые начинаются с /api/v2 и заканчивается на /methods остальные части пути при сравнении будут проигнорированы
        - патерн может содержать в конце символ ```$``` это означает, что путь запроса должен иметь определенную длинну в частях пути
          например патерн: ```/api/v2/*/*/methods$``` будет соответствовать пути запроса начинающегося с /api/v2 далее две следующие части не имеют значения и последняя часть methods т.е. путь должен будет состоять из 5 частей
          а паттерн: ```/api/v2/*/*/methods``` будет соответствовать пути запроса начинающегося с /api/v2 далее две следующие части не имеют значения и следующая часть methods дальныйшие части пути не важны 
      - headerkey и headerval:
        эти части правила сравниваются с ключами из заголовка запроса, то есть заголовок запроса должен содержать указаный ключ и соответствующее значение и ключи и значе
        если оба или одно из этих значений не указаны, то они в проверках не участвуют
  - limit:
    лимит скорости в запросах в секунду. на запросы сверх лимита будет отправлен ответ со статусом: 429 Too Many Requests


Тестирование:
  - должно заключаться в записи в keeper json-а c описаными выше параметрами и ключем keeper = keeperRateLimitKey из настроек middleware (будут обговорены при создании стенда),
  - далее дождаться что конфигурация будет загужена в плагин traefik. загрузка происходит каждые 30 секунд.
  - далее направлять в сторону ресурса запросы. запрос должен будет состоять из статической часть например http://nginx.k8s.local (будет обговорено при создании стенда) 
    и изменяемой части пути запроса и содержать ключи и значения заголовка или не содержать их для проверки работы правил в соответствии с описанием настроек см. выше.
  - запросы которые соответствуют правилам и выходят за лимиты указанные в настройках должен приходить ответ состатусом 429 Too Many Requests
    далее повторять данные действия изменяя настройки и отправляемые запросы и частоту отправки запросов


Тестовые кейсы:
  - создать првила и посмотреть что они срабатывают согласно настройкам. 
    Реализовать можно следующим образом слелать лимит по правилу равным 1 и подавать два запроса соответсвущих правилу один за другим первый запрос должен быть пропущен а второй нет.
    если не будет ни одного правила соответствующего запросу то оба запроса должны быть пропущены
  - сделать правило и в момент работы изменить по правилу лимит, и посмотреть что лимит по запросам изменился без перебоев, 
    то есть нет запросов не получивших ответа с ошибкеми либо статусами500 передачи и.т.п
    Проверку проводить возможно следующим образом в течении минуты отправлять в адрес запросы с какойто частотой возможно даже с максимальной
    и по секундам записывать в три переменных значения количества запросов со статусом в ответе:
    - 429 (не пропущеные к сервису запросы) 
    - 200 или 404 (пропущеные к сезапросов)
    - другие статусы либо запросы без ответа (Запросы по которым произошла ошибка io либо другие)
    - сравнение количества пропущеных запросов с требуемым согласно настройкам
    и выдать это в виде таблицы.
  - померить какое максиматьное количество запросов вообще возможно обработать без перебоев когда на каждый запрос приходит либо положительный ответ дибо отрицательный
    и нет запросов без ответа или с ошибкой ввода вывода либо проверку можно провести ка описано выше




