# ratelimiter - traefik_ratelimiter

Плагин для сервиса traefik "ratelimiter".

## 1.1. Хранение конфигурации

конфигурация ratelimiter загружается из keeper для оперативного управления ratelimiter или из параметров middleware **ratelimitData** при инициализации 
плагина в случае недоступности keeper.
данная конфигурация предназначены для конфигурирования лимитов скорости обработки запросов в зависимости от пути и/или содержимого заголовка запроса.
конфигурация, включает следующие параметры:

- **Лимиты (`limits`)**
    - *Тип:* Массив структур
    - *Обязательность:* Да

  - **Правила (`rules`)**
      - *Тип:* Массив структур
      - *Обязательность:* Да
      - *Примечание:* Содержит правила выбора запросов для лимитирования скорости. для применеия лимита дочтаточно соответствия хотя бы одному правилу
        в любом правиле должны быть указан **urlpathpattern** и/или **headerkey** и **headerval**. 
        Например если значение **urlpathpattern** пустое, то спавнение производится только с **headerkey** и **headerval** и\
        наоборот если **headerkey** или **headerval** пустые, то сравнение производится только с **urlpathpattern**
        если не пустые **urlpathpattern** и **headerkey** и **headerval** то спавнение производится по всем элементам вместе
        примеры правил:
          - ```{
                "rules": [
                  {"urlpathpattern": "/api/v2/merchants/*/users/*/payments/methods$"}
                ],
                "limit": 10000
              }``` - лимит 10000 rps будет применен ко ВСЕМ ВВМЕСТЕ запросам совпадаюшим с правилом имеющим вид патерна пути
      - **Паттерн пути (`urlpathpattern`)**
        - *Тип:* Строка
        - *Обязательность:* Да
        - *Чуствительность к регистру:* Да
        - *Примечание:* Если значение не пустое, то правило будет применено если путь http запроса соответствует паттеру. Описание:
          - паттерн содержит элементы пути http запроса разделенные символом **/**. элементы пути запроса в паттерне сравниваются с соответствующими частями пути запроса на полное равенство
          - паттерн может содержать в элементе пути ```*``` это означает эта часть пути запроса может содержать любое значение, но эта часть пути должна присутствовать обязательно
          - паттерн может содержать в элементе пути значение ```**``` (может присутствовать в паттерне в единстаенном экземпляре) это означает что остальная часть пути будет сравниваться с хвостом пути
            например:
              - патерну ```"/api/v2/**/methods"``` будут соответствовать пути запроса которые начинаются с /api/v2 и заканчивается на /methods : /api/v2/methods, /api/v2/test/methods
              - патерну ```"/api/v2/**/*/methods"``` будут соответствовать пути запроса которые начинаются с /api/v2 и заканчивается на /methods , но перед methods должен присутствовать любой элемент
              - патерну ```"/**/methods"``` будут соответствовать пути запроса которые заканчивается на /methods
          - патерн может содержать в конце символ ```$``` (в том случае если он содержит ```**``` будет проигнорирован )
            это означает, что путь запроса должен иметь определенную длинну в элементах пути
            например:
              - паттерн ```"/api/v2/*/*/methods$"``` будет соответствовать пути запроса начинающегося с /api/v2 далее две следующие элементы не имеют значения, но должыны присутствовать и последний элемент methods 
                и путь должен состоять ровно из 5 элементов
              - паттерн ```"/api/v2/*/*/methods"``` будет соответствовать пути запроса начинающегося с /api/v2 далее два следующие элемента не имеют значения, но должны присутствовать
                и следующий элемент methods при этом длинна в элементах пути может быть  больше либо равна 5
          примеры паттернов:
            - ```"$"``` - соответстыует пустому пути
            - ```"/$"```- соответствует ```/``` пути запроса

      - **Ключ из заголовка http запроса (`headerkey`)**
        - *Тип:* Строка
        - *Обязательность:* Да
        - *Чуствительность к регистру:* Нет
        - *Примечание:* Значение ключа из http запроса. Если значение не пустое, то правило будет применено в том случае если запрос содержит значение headerval в значении заголовка соответстущего ключа
          для того чтобы условие применялось поле headerval должно содержать не пустое значение

      - **Значение соответствующего ключа из заголовка (`headerval`)**
        - *Тип:* Строка
        - *Обязательность:* Да
        - *Чуствительность к регистру:* Нет
        - *Примечание:* Значение соответствующего ключа в запросе используется только в случае если оно содержит не пустое значение.  Данное значение используется только в том случае если указано не пустое значение headerkey


  - **Лимит (`limit`)**
      - *Тип:* Целое число больше нуля
      - *Обязательность:* Да
      - *Примечание:*  Лимит скорости в запросах в секунду. На запросы сверх лимита будет отправлен ответ со статусом: 429 Too Many Requests.



Конфигурация хранится в локальном кеше ratelimiter

## 1.2. Обновление конфигурации

Конфигурация обновляется периодически 1 раз в 30 сек из keeper


## Логика работы ratelimiter

Плагин сравнивает входяшие запросы со списком правил при совпадении с правилами подсчитывает текущую скорость запросов по правилу
и если скорость превышает указанный лимит запрос не передается на дальнейшую обработку а создается ответ на запрос со статусом 429 Too Many Requests.

## Тестирование

- должно заключаться в записи в keeper json-а c описаными выше параметрами и ключем keeper = keeperRateLimitKey из настроек middleware (будут обговорены при создании стенда),
- далее дождаться что конфигурация будет загужена в плагин traefik. загрузка происходит каждые 30 на время тестирования сменим на 5.
- далее направлять в сторону ресурса запросы. запрос должен будет состоять из статической часть например http://nginx.k8s.local (будет обговорено при создании стенда) 
  и изменяемой части пути запроса и содержать ключи и значения заголовка или не содержать их для проверки работы правил в соответствии с описанием настроек см. выше.
- запросы которые соответствуют правилам и выходят за лимиты указанные в настройках должен приходить ответ состатусом 429 Too Many Requests
- далее повторять данные действия изменяя настройки и отправляемые запросы и частоту отправки запросов


## Тестовые кейсы

- создать првила и посмотреть что они срабатывают согласно настройкам. 
  Реализовать можно следующим образом слелать лимит по правилу равным 1 и подавать два запроса соответсвущих правилу один за другим первый запрос должен быть пропущен а второй нет.
  если не будет ни одного правила соответствующего запросу то оба запроса должны быть пропущены (не иметь статус ответа 429)
- сделать правило и в момент работы изменить по правилу лимит, и посмотреть что лимит по запросам изменился без перебоев, 
  то есть нет запросов не получивших ответа с ошибкеми передачи либо статусами больше равными 500
  Проверку проводить возможно следующим образом в течении минуты отправлять в адрес запросы с какойто частотой возможно даже с максимальной
  и по секундам записывать в три переменных значения количества запросов со статусом в ответе:
  - 429 (не пропущеные к сервису запросы) 
  - 200 или 404 (пропущеные к сезапросов)
  - другие статусы либо запросы без ответа (Запросы по которым произошла ошибка io либо другие)
  - сравнение количества пропущеных запросов с требуемым согласно настройкам
  и выдать это в виде таблицы.
- померить какое максиматльное количество запросов вообще возможно обработать без перебоев когда на каждый запрос приходит либо положительный ответ дибо отрицательный
  и нет запросов без ответа или с ошибкой ввода вывода либо проверку можно провести как описано выше

